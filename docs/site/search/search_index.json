{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NDF Studio Backend Documentation","text":"<p>Welcome to the comprehensive documentation for the NDF Studio backend API and implementation.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>NDF Studio is a Node-neighborhood Description Framework that provides a powerful backend API for managing graph-based knowledge representations.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Graph Management: Create, update, and manage complex graph structures</li> <li>Node Operations: Handle polymorphic nodes with multiple morphs</li> <li>Relation Management: Define and manage relationships between nodes</li> <li>Authentication: Secure user management with JWT tokens</li> <li>CNL Parsing: Natural language processing for graph descriptions</li> </ul>"},{"location":"#documentation-sections","title":"\ud83d\udcda Documentation Sections","text":""},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Core Modules: Core functionality including models, utilities, and validation</li> <li>Routes: API endpoints for graph operations, user management, and more</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Installation: Setup instructions for developers</li> </ul>"},{"location":"#getting-started","title":"\ud83d\udd27 Getting Started","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>FastAPI</li> <li>SQLModel</li> <li>spaCy</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/gnowledge/nodeBook.git\ncd nodeBook\n\n# Install dependencies\npip install -r backend/requirements.txt\n\n# Run the development server\nbash scripts/start_backend.sh\n</code></pre>"},{"location":"#api-access","title":"API Access","text":"<p>Once running, you can access: - API Documentation: http://localhost:8000/docs - Alternative Docs: http://localhost:8000/redoc - Health Check: http://localhost:8000/api/health</p>"},{"location":"#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<p>NDF Studio backend is built with: - FastAPI: Modern, fast web framework - SQLModel: SQL databases in Python, designed for compatibility with both SQLAlchemy Core and Pydantic - Pydantic: Data validation using Python type annotations - JWT: Secure authentication with inactivity-based token expiration</p>"},{"location":"#api-examples","title":"\ud83d\udcd6 API Examples","text":""},{"location":"#creating-a-graph","title":"Creating a Graph","text":"<pre><code>import requests\n\n# Create a new graph\nresponse = requests.post(\n    \"http://localhost:8000/api/ndf/users/{user_id}/graphs/{graph_id}\",\n    json={\n        \"title\": \"My Knowledge Graph\",\n        \"description\": \"A graph representing domain knowledge\"\n    }\n)\n</code></pre>"},{"location":"#parsing-cnl","title":"Parsing CNL","text":"<pre><code># Parse CNL (Controlled Natural Language) into graph structure\nwith open(\"graph.cnl\", \"rb\") as f:\n    response = requests.post(\n        \"http://localhost:8000/api/ndf/users/{user_id}/graphs/{graph_id}/parse_pipeline\",\n        files={\"file\": f}\n    )\n</code></pre>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Please see our Installation Guide for setup instructions.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"api/core/models/","title":"Core Models","text":"<p>This section documents the core data models used throughout the NDF Studio backend.</p>"},{"location":"api/core/models/#backend.core.models","title":"<code>backend.core.models</code>","text":"<p>NDF Studio Core Data Models</p> <p>This module defines the core data models used throughout the NDF Studio backend. These models represent the fundamental entities in the Node-neighborhood Description Framework.</p> <p>Classes:</p> Name Description <code>Relation</code> <p>Represents a fundamental edge/relationship between nodes</p> <code>AttributeNode</code> <p>Scalar value modeled as a node-connected attribute</p> <code>Attribute</code> <p>Legacy attribute model for backward compatibility</p> <code>Node</code> <p>Legacy mono-morphic node model</p> <code>Morph</code> <p>Represents a variation in neighborhood</p> <code>PolyNode</code> <p>Polymorphic node model with multiple morphs</p> <code>Transition</code> <p>Represents state transitions with optional tense</p> <code>Function</code> <p>Represents functional transformations</p> <code>RelationNode</code> <p>Relation modeled as a node-connected entity</p>"},{"location":"api/core/models/#backend.core.models-classes","title":"Classes","text":""},{"location":"api/core/models/#backend.core.models.Relation","title":"<code>Relation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a fundamental edge/relationship between nodes in the graph.</p> <p>This model defines the basic structure for relationships between nodes, including optional adverbs and modalities to qualify the relationship.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the relation</p> <code>name</code> <code>str</code> <p>Name/type of the relation (e.g., \"contains\", \"is_a\")</p> <code>source</code> <code>str</code> <p>ID of the source node</p> <code>target</code> <code>str</code> <p>ID of the target node</p> <code>adverb</code> <code>Optional[str]</code> <p>Optional adverb to qualify the relation</p> <code>modality</code> <code>Optional[str]</code> <p>Optional modality (e.g., \"possibly\", \"necessarily\")</p> Source code in <code>backend/core/models.py</code> <pre><code>class Relation(BaseModel):\n    \"\"\"\n    Represents a fundamental edge/relationship between nodes in the graph.\n\n    This model defines the basic structure for relationships between nodes,\n    including optional adverbs and modalities to qualify the relationship.\n\n    Attributes:\n        id (str): Unique identifier for the relation\n        name (str): Name/type of the relation (e.g., \"contains\", \"is_a\")\n        source (str): ID of the source node\n        target (str): ID of the target node\n        adverb (Optional[str]): Optional adverb to qualify the relation\n        modality (Optional[str]): Optional modality (e.g., \"possibly\", \"necessarily\")\n    \"\"\"\n    id: str\n    name: str\n    source: str\n    target: str\n    adverb: Optional[str] = None\n    modality: Optional[str] = None\n</code></pre>"},{"location":"api/core/models/#backend.core.models.AttributeNode","title":"<code>AttributeNode</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Scalar value modeled as a node-connected attribute.</p> <p>This model represents attributes that are connected to nodes, allowing for more complex attribute structures than simple key-value pairs.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[str]</code> <p>Unique identifier for the attribute node</p> <code>name</code> <code>str</code> <p>Name of the attribute</p> <code>source_id</code> <code>str</code> <p>ID of the node this attribute belongs to</p> <code>value</code> <code>Union[str, float, int, bool]</code> <p>The attribute value</p> <code>unit</code> <code>Optional[str]</code> <p>Optional unit of measurement</p> <code>adverb</code> <code>Optional[str]</code> <p>Optional adverb to qualify the attribute</p> <code>modality</code> <code>Optional[str]</code> <p>Optional modality for the attribute</p> <code>morph_id</code> <code>Optional[List[str]]</code> <p>List of morph IDs this attribute belongs to</p> Source code in <code>backend/core/models.py</code> <pre><code>class AttributeNode(BaseModel):\n    \"\"\"\n    Scalar value modeled as a node-connected attribute.\n\n    This model represents attributes that are connected to nodes,\n    allowing for more complex attribute structures than simple key-value pairs.\n\n    Attributes:\n        id (Optional[str]): Unique identifier for the attribute node\n        name (str): Name of the attribute\n        source_id (str): ID of the node this attribute belongs to\n        value (Union[str, float, int, bool]): The attribute value\n        unit (Optional[str]): Optional unit of measurement\n        adverb (Optional[str]): Optional adverb to qualify the attribute\n        modality (Optional[str]): Optional modality for the attribute\n        morph_id (Optional[List[str]]): List of morph IDs this attribute belongs to\n    \"\"\"\n    id: Optional[str] = None\n    name: str\n    source_id: str\n    value: Union[str, float, int, bool]\n    unit: Optional[str] = None\n    adverb: Optional[str] = None\n    modality: Optional[str] = None\n    morph_id: Optional[List[str]] = None\n</code></pre>"},{"location":"api/core/models/#backend.core.models.Attribute","title":"<code>Attribute</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Legacy attribute model for backward compatibility.</p> <p>This model represents simple key-value attributes attached to nodes. It's maintained for backward compatibility with existing code.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the attribute</p> <code>node_id</code> <code>str</code> <p>ID of the node this attribute belongs to</p> <code>name</code> <code>str</code> <p>Name of the attribute</p> <code>value</code> <code>Union[str, float, int, bool, None]</code> <p>The attribute value</p> <code>unit</code> <code>Optional[str]</code> <p>Optional unit of measurement</p> <code>adverb</code> <code>Optional[str]</code> <p>Optional adverb to qualify the attribute</p> <code>modality</code> <code>Optional[str]</code> <p>Optional modality for the attribute</p> Source code in <code>backend/core/models.py</code> <pre><code>class Attribute(BaseModel):\n    \"\"\"\n    Legacy attribute model for backward compatibility.\n\n    This model represents simple key-value attributes attached to nodes.\n    It's maintained for backward compatibility with existing code.\n\n    Attributes:\n        id (str): Unique identifier for the attribute\n        node_id (str): ID of the node this attribute belongs to\n        name (str): Name of the attribute\n        value (Union[str, float, int, bool, None]): The attribute value\n        unit (Optional[str]): Optional unit of measurement\n        adverb (Optional[str]): Optional adverb to qualify the attribute\n        modality (Optional[str]): Optional modality for the attribute\n    \"\"\"\n    id: str\n    node_id: str\n    name: str\n    value: Union[str, float, int, bool, None] = None\n    unit: Optional[str] = None\n    adverb: Optional[str] = None\n    modality: Optional[str] = None\n</code></pre>"},{"location":"api/core/models/#backend.core.models.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Legacy mono-morphic node model.</p> <p>This model represents a simple node with a single neighborhood. It's maintained for backward compatibility with existing code.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[str]</code> <p>Unique identifier for the node</p> <code>name</code> <code>str</code> <p>Name of the node</p> <code>base_name</code> <code>Optional[str]</code> <p>Base name without qualifiers</p> <code>qualifier</code> <code>Optional[str]</code> <p>Optional qualifier for the node</p> <code>role</code> <code>Optional[Literal['class', 'individual', 'process']]</code> <p>Role of the node</p> <code>description</code> <code>Optional[str]</code> <p>Optional description of the node</p> <code>attributes</code> <code>List[Attribute]</code> <p>List of attributes attached to the node</p> <code>relations</code> <code>List[Relation]</code> <p>List of relations connected to the node</p> Source code in <code>backend/core/models.py</code> <pre><code>class Node(BaseModel):\n    \"\"\"\n    Legacy mono-morphic node model.\n\n    This model represents a simple node with a single neighborhood.\n    It's maintained for backward compatibility with existing code.\n\n    Attributes:\n        id (Optional[str]): Unique identifier for the node\n        name (str): Name of the node\n        base_name (Optional[str]): Base name without qualifiers\n        qualifier (Optional[str]): Optional qualifier for the node\n        role (Optional[Literal[\"class\", \"individual\", \"process\"]]): Role of the node\n        description (Optional[str]): Optional description of the node\n        attributes (List[Attribute]): List of attributes attached to the node\n        relations (List[Relation]): List of relations connected to the node\n    \"\"\"\n    id: Optional[str] = None\n    name: str\n    base_name: Optional[str] = None\n    qualifier: Optional[str] = None  # &lt;-- allow any string, not Literal\n    role: Optional[Literal[\"class\", \"individual\", \"process\"]] = None\n    description: Optional[str] = None\n    attributes: List[Attribute] = []\n    relations: List[Relation] = []\n</code></pre>"},{"location":"api/core/models/#backend.core.models.Morph","title":"<code>Morph</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a variation in neighborhood.</p> <p>A morph defines a specific variation or context of a polymorphic node. Each morph can have its own set of relations and attributes.</p> <p>Attributes:</p> Name Type Description <code>morph_id</code> <code>str</code> <p>Unique identifier for the morph</p> <code>node_id</code> <code>str</code> <p>ID of the parent polymorphic node</p> <code>name</code> <code>str</code> <p>Name of the morph</p> <code>relationNode_ids</code> <code>Optional[List[str]]</code> <p>List of relation node IDs in this morph</p> <code>attributeNode_ids</code> <code>Optional[List[str]]</code> <p>List of attribute node IDs in this morph</p> Source code in <code>backend/core/models.py</code> <pre><code>class Morph(BaseModel):\n    \"\"\"\n    Represents a variation in neighborhood.\n\n    A morph defines a specific variation or context of a polymorphic node.\n    Each morph can have its own set of relations and attributes.\n\n    Attributes:\n        morph_id (str): Unique identifier for the morph\n        node_id (str): ID of the parent polymorphic node\n        name (str): Name of the morph\n        relationNode_ids (Optional[List[str]]): List of relation node IDs in this morph\n        attributeNode_ids (Optional[List[str]]): List of attribute node IDs in this morph\n    \"\"\"\n    morph_id: str\n    node_id: str\n    name: str\n    relationNode_ids: Optional[List[str]] = []\n    attributeNode_ids: Optional[List[str]] = []\n</code></pre>"},{"location":"api/core/models/#backend.core.models.PolyNode","title":"<code>PolyNode</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Polymorphic node model with multiple morphs.</p> <p>This model represents a node that can exist in multiple variations (morphs), each with its own neighborhood of relations and attributes.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[str]</code> <p>Unique identifier for the polymorphic node</p> <code>name</code> <code>Optional[str]</code> <p>Computed name from base_name + adjective</p> <code>base_name</code> <code>str</code> <p>Required base name for ID generation</p> <code>adjective</code> <code>Optional[str]</code> <p>Optional adjective to qualify the node</p> <code>quantifier</code> <code>Optional[str]</code> <p>Optional quantifier (e.g., \"all\", \"some\")</p> <code>role</code> <code>Optional[str]</code> <p>Role of the node, defaults to \"individual\"</p> <code>description</code> <code>Optional[str]</code> <p>Optional description of the node</p> <code>morphs</code> <code>Optional[List[Morph]]</code> <p>List of morphs for this node</p> <code>nbh</code> <code>Optional[str]</code> <p>Currently active morph name</p> Source code in <code>backend/core/models.py</code> <pre><code>class PolyNode(BaseModel):\n    \"\"\"\n    Polymorphic node model with multiple morphs.\n\n    This model represents a node that can exist in multiple variations (morphs),\n    each with its own neighborhood of relations and attributes.\n\n    Attributes:\n        id (Optional[str]): Unique identifier for the polymorphic node\n        name (Optional[str]): Computed name from base_name + adjective\n        base_name (str): Required base name for ID generation\n        adjective (Optional[str]): Optional adjective to qualify the node\n        quantifier (Optional[str]): Optional quantifier (e.g., \"all\", \"some\")\n        role (Optional[str]): Role of the node, defaults to \"individual\"\n        description (Optional[str]): Optional description of the node\n        morphs (Optional[List[Morph]]): List of morphs for this node\n        nbh (Optional[str]): Currently active morph name\n    \"\"\"\n    id: Optional[str] = None  # Optional since we compute it during creation\n    name: Optional[str] = None  # Optional since we can compute it from base_name + adjective\n    base_name: str  # Required for ID generation\n    adjective: Optional[str] = None\n    quantifier: Optional[str] = None\n    role: Optional[str] = \"individual\"  # Default to individual like Node model\n    description: Optional[str] = None\n    morphs: Optional[List[Morph]] = []\n    nbh: Optional[str] = None  # currently active morph\n</code></pre>"},{"location":"api/core/models/#backend.core.models.Transition","title":"<code>Transition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents state transitions with optional tense.</p> <p>This model defines transitions between different states or morphs of nodes, including temporal information about when the transition occurs.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the transition</p> <code>name</code> <code>Optional[str]</code> <p>Name of the transition</p> <code>adjective</code> <code>Optional[str]</code> <p>Optional adjective to qualify the transition</p> <code>tense</code> <code>Optional[str]</code> <p>Tense of the transition (e.g., \"past\", \"present\", \"future\")</p> <code>inputs</code> <code>List[dict]</code> <p>List of input nodes with their morphs</p> <code>outputs</code> <code>List[dict]</code> <p>List of output nodes with their morphs</p> <code>description</code> <code>Optional[str]</code> <p>Optional description of the transition</p> Source code in <code>backend/core/models.py</code> <pre><code>class Transition(BaseModel):\n    \"\"\"\n    Represents state transitions with optional tense.\n\n    This model defines transitions between different states or morphs of nodes,\n    including temporal information about when the transition occurs.\n\n    Attributes:\n        id (str): Unique identifier for the transition\n        name (Optional[str]): Name of the transition\n        adjective (Optional[str]): Optional adjective to qualify the transition\n        tense (Optional[str]): Tense of the transition (e.g., \"past\", \"present\", \"future\")\n        inputs (List[dict]): List of input nodes with their morphs\n        outputs (List[dict]): List of output nodes with their morphs\n        description (Optional[str]): Optional description of the transition\n    \"\"\"\n    id: str\n    name: Optional[str]\n    adjective: Optional[str] = None\n    tense: Optional[str] = None  # e.g., \"past\", \"present\", \"future\"\n    inputs: List[dict]  # {id: node_id, nbh: morph_name}\n    outputs: List[dict]\n    description: Optional[str] = None\n</code></pre>"},{"location":"api/core/models/#backend.core.models.Function","title":"<code>Function</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents functional transformations.</p> <p>This model defines functions that transform inputs into outputs, representing computational or logical operations in the graph.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the function</p> <code>name</code> <code>Optional[str]</code> <p>Name of the function</p> <code>inputs</code> <code>List[str]</code> <p>List of input node IDs</p> <code>outputs</code> <code>List[str]</code> <p>List of output node IDs</p> <code>description</code> <code>Optional[str]</code> <p>Optional description of the function</p> Source code in <code>backend/core/models.py</code> <pre><code>class Function(BaseModel):\n    \"\"\"\n    Represents functional transformations.\n\n    This model defines functions that transform inputs into outputs,\n    representing computational or logical operations in the graph.\n\n    Attributes:\n        id (str): Unique identifier for the function\n        name (Optional[str]): Name of the function\n        inputs (List[str]): List of input node IDs\n        outputs (List[str]): List of output node IDs\n        description (Optional[str]): Optional description of the function\n    \"\"\"\n    id: str\n    name: Optional[str]\n    inputs: List[str]\n    outputs: List[str]\n    description: Optional[str] = None\n</code></pre>"},{"location":"api/core/models/#backend.core.models.RelationNode","title":"<code>RelationNode</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Relation modeled as a node-connected entity.</p> <p>This model represents relations as first-class nodes in the graph, allowing for more complex relationship structures.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[str]</code> <p>Unique identifier for the relation node</p> <code>name</code> <code>str</code> <p>Name of the relation</p> <code>source_id</code> <code>str</code> <p>ID of the source node</p> <code>target_id</code> <code>str</code> <p>ID of the target node</p> <code>adverb</code> <code>Optional[str]</code> <p>Optional adverb to qualify the relation</p> <code>modality</code> <code>Optional[str]</code> <p>Optional modality for the relation</p> <code>morph_id</code> <code>Optional[List[str]]</code> <p>List of morph IDs this relation belongs to</p> Source code in <code>backend/core/models.py</code> <pre><code>class RelationNode(BaseModel):\n    \"\"\"\n    Relation modeled as a node-connected entity.\n\n    This model represents relations as first-class nodes in the graph,\n    allowing for more complex relationship structures.\n\n    Attributes:\n        id (Optional[str]): Unique identifier for the relation node\n        name (str): Name of the relation\n        source_id (str): ID of the source node\n        target_id (str): ID of the target node\n        adverb (Optional[str]): Optional adverb to qualify the relation\n        modality (Optional[str]): Optional modality for the relation\n        morph_id (Optional[List[str]]): List of morph IDs this relation belongs to\n    \"\"\"\n    id: Optional[str] = None\n    name: str\n    source_id: str\n    target_id: str\n    adverb: Optional[str] = None\n    modality: Optional[str] = None\n    morph_id: Optional[List[str]] = None\n</code></pre>"},{"location":"api/core/utils/","title":"Core Utilities","text":"<p>This section documents the utility functions and helpers used throughout the NDF Studio backend.</p>"},{"location":"api/core/utils/#backend.core.utils","title":"<code>backend.core.utils</code>","text":"<p>NDF Studio Core Utilities</p> <p>This module provides utility functions used throughout the NDF Studio backend. These utilities handle common operations like file I/O, text processing, and data normalization.</p> <p>Functions:</p> Name Description <code>render_description_md</code> <p>Converts markdown text to safe HTML</p> <code>normalize_id</code> <p>Normalizes strings to valid identifiers</p> <code>save_json_file</code> <p>Saves data to JSON file</p> <code>load_json_file</code> <p>Loads data from JSON file</p> <code>load_text_file</code> <p>Loads text content from file</p>"},{"location":"api/core/utils/#backend.core.utils-functions","title":"Functions","text":""},{"location":"api/core/utils/#backend.core.utils.render_description_md","title":"<code>render_description_md(text: Optional[str]) -&gt; str</code>","text":"<p>Converts markdown text to safe HTML for display.</p> <p>This function takes markdown text and converts it to HTML, then sanitizes the HTML to prevent XSS attacks by allowing only safe tags and attributes.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Optional[str]</code> <p>Markdown text to convert and sanitize</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Safe HTML string ready for display</p> Example <p>render_description_md(\"Bold text and link\") '<p>Bold text and link</p>'</p> Source code in <code>backend/core/utils.py</code> <pre><code>def render_description_md(text: Optional[str]) -&gt; str:\n    \"\"\"\n    Converts markdown text to safe HTML for display.\n\n    This function takes markdown text and converts it to HTML, then sanitizes\n    the HTML to prevent XSS attacks by allowing only safe tags and attributes.\n\n    Args:\n        text (Optional[str]): Markdown text to convert and sanitize\n\n    Returns:\n        str: Safe HTML string ready for display\n\n    Example:\n        &gt;&gt;&gt; render_description_md(\"**Bold text** and [link](http://example.com)\")\n        '&lt;p&gt;&lt;strong&gt;Bold text&lt;/strong&gt; and &lt;a href=\"http://example.com\"&gt;link&lt;/a&gt;&lt;/p&gt;'\n    \"\"\"\n    raw_html = markdown.markdown(text or \"\")\n    safe_html = bleach.clean(\n        raw_html,\n        tags=[\"p\", \"b\", \"i\", \"strong\", \"em\", \"ul\", \"ol\", \"li\", \"a\", \"code\", \"pre\", \"blockquote\"],\n        attributes={\"a\": [\"href\"]},\n    )\n    return safe_html\n</code></pre>"},{"location":"api/core/utils/#backend.core.utils.normalize_id","title":"<code>normalize_id(name: str) -&gt; str</code>","text":"<p>Normalizes a string to create a valid identifier.</p> <p>This function converts a string to a valid identifier by: - Trimming whitespace - Converting to lowercase - Replacing spaces with underscores</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The string to normalize</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Normalized identifier string</p> Example <p>normalize_id(\"  My Node Name  \") 'my_node_name'</p> Source code in <code>backend/core/utils.py</code> <pre><code>def normalize_id(name: str) -&gt; str:\n    \"\"\"\n    Normalizes a string to create a valid identifier.\n\n    This function converts a string to a valid identifier by:\n    - Trimming whitespace\n    - Converting to lowercase\n    - Replacing spaces with underscores\n\n    Args:\n        name (str): The string to normalize\n\n    Returns:\n        str: Normalized identifier string\n\n    Example:\n        &gt;&gt;&gt; normalize_id(\"  My Node Name  \")\n        'my_node_name'\n    \"\"\"\n    return name.strip().lower().replace(\" \", \"_\")\n</code></pre>"},{"location":"api/core/utils/#backend.core.utils.save_json_file","title":"<code>save_json_file(path: Path, data: Dict[str, Any]) -&gt; None</code>","text":"<p>Saves data to a JSON file with proper formatting.</p> <p>This function saves a dictionary to a JSON file with UTF-8 encoding and pretty formatting (2-space indentation).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file to create/overwrite</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary data to save</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If the file cannot be written</p> <code>TypeError</code> <p>If the data cannot be serialized to JSON</p> Example <p>save_json_file(Path(\"config.json\"), {\"key\": \"value\"})</p> Source code in <code>backend/core/utils.py</code> <pre><code>def save_json_file(path: Path, data: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Saves data to a JSON file with proper formatting.\n\n    This function saves a dictionary to a JSON file with UTF-8 encoding\n    and pretty formatting (2-space indentation).\n\n    Args:\n        path (Path): Path to the JSON file to create/overwrite\n        data (Dict[str, Any]): Dictionary data to save\n\n    Raises:\n        IOError: If the file cannot be written\n        TypeError: If the data cannot be serialized to JSON\n\n    Example:\n        &gt;&gt;&gt; save_json_file(Path(\"config.json\"), {\"key\": \"value\"})\n        # Creates config.json with: {\"key\": \"value\"}\n    \"\"\"\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=2)\n</code></pre>"},{"location":"api/core/utils/#backend.core.utils.save_json_file--creates-configjson-with-key-value","title":"Creates config.json with: {\"key\": \"value\"}","text":""},{"location":"api/core/utils/#backend.core.utils.load_json_file","title":"<code>load_json_file(path: Path) -&gt; Dict[str, Any]</code>","text":"<p>Loads data from a JSON file.</p> <p>This function reads a JSON file and returns the parsed dictionary. The file is expected to be UTF-8 encoded.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file to read</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Parsed JSON data as a dictionary</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>JSONDecodeError</code> <p>If the file contains invalid JSON</p> <code>IOError</code> <p>If the file cannot be read</p> Example <p>data = load_json_file(Path(\"config.json\")) print(data) {'key': 'value'}</p> Source code in <code>backend/core/utils.py</code> <pre><code>def load_json_file(path: Path) -&gt; Dict[str, Any]:\n    \"\"\"\n    Loads data from a JSON file.\n\n    This function reads a JSON file and returns the parsed dictionary.\n    The file is expected to be UTF-8 encoded.\n\n    Args:\n        path (Path): Path to the JSON file to read\n\n    Returns:\n        Dict[str, Any]: Parsed JSON data as a dictionary\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        json.JSONDecodeError: If the file contains invalid JSON\n        IOError: If the file cannot be read\n\n    Example:\n        &gt;&gt;&gt; data = load_json_file(Path(\"config.json\"))\n        &gt;&gt;&gt; print(data)\n        {'key': 'value'}\n    \"\"\"\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"api/core/utils/#backend.core.utils.load_text_file","title":"<code>load_text_file(path: Path) -&gt; str</code>","text":"<pre><code>Loads text content from a file.\n\nThis function reads a text file and returns its content as a string.\nThe file is expected to be UTF-8 encoded.\n\nArgs:\n    path (Path): Path to the text file to read\n\nReturns:\n    str: Content of the text file\n\nRaises:\n    FileNotFoundError: If the file doesn't exist\n    IOError: If the file cannot be read\n\nExample:\n    &gt;&gt;&gt; content = load_text_file(Path(\"readme.md\"))\n    &gt;&gt;&gt; print(content[:50])\n    '# NDF Studio Documentation\n</code></pre> <p>This is the main...'</p> Source code in <code>backend/core/utils.py</code> <pre><code>def load_text_file(path: Path) -&gt; str:\n    \"\"\"\n    Loads text content from a file.\n\n    This function reads a text file and returns its content as a string.\n    The file is expected to be UTF-8 encoded.\n\n    Args:\n        path (Path): Path to the text file to read\n\n    Returns:\n        str: Content of the text file\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        IOError: If the file cannot be read\n\n    Example:\n        &gt;&gt;&gt; content = load_text_file(Path(\"readme.md\"))\n        &gt;&gt;&gt; print(content[:50])\n        '# NDF Studio Documentation\\n\\nThis is the main...'\n    \"\"\"\n    with path.open(\"r\", encoding=\"utf-8\") as f:\n        return f.read()    \n</code></pre>"},{"location":"api/routes/graph_ops/","title":"Graph Operations","text":"<p>This section documents the graph operation endpoints and their functionality.</p>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops","title":"<code>backend.routes.graph_ops</code>","text":"<p>This module provides API endpoints and helper functions for managing node attributes and relations in the NDF Studio knowledge graph backend.</p> <p>Key Features: - All node data is stored as JSON files under graph_data/users/{user_id}/nodes/{node_id}.json. - Attribute and relation types are validated against global schema files (attribute_types.json, relation_types.json). - Endpoints support full CRUD (create, update, delete) for both attributes and relations. - When creating or updating a relation, if the source or target node does not exist, the canonical create_node function from nodes.py is called to ensure proper node creation and registry updates. - All endpoints are designed for robust integration with the frontend, supporting both selection and creation of new nodes/relations/attributes.</p> <p>Endpoints: - POST   /users/{user_id}/graphs/{graph_id}/attribute/create - PUT    /users/{user_id}/graphs/{graph_id}/attribute/update/{node_id}/{attr_name} - DELETE /users/{user_id}/graphs/{graph_id}/attribute/delete/{node_id}/{attr_name} - POST   /users/{user_id}/graphs/{graph_id}/relation/create - PUT    /users/{user_id}/graphs/{graph_id}/relation/update/{source}/{name}/{target} - DELETE /users/{user_id}/graphs/{graph_id}/relation/delete/{source}/{name}/{target}</p> <p>Helpers: - node_path, load_node, save_node: JSON-based node storage helpers. - load_schema: Loads global schema files for validation.</p> <p>All logic is designed to be robust, extensible, and consistent with the rest of the backend.</p>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops-classes","title":"Classes","text":""},{"location":"api/routes/graph_ops/#backend.routes.graph_ops-functions","title":"Functions","text":""},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.get_attribute_node","title":"<code>get_attribute_node(user_id: str, graph_id: str, attribute_id: str)</code>","text":"<p>Get a specific attribute node by its ID</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.get(\"/users/{user_id}/graphs/{graph_id}/attributeNodes/{attribute_id}\")\ndef get_attribute_node(user_id: str, graph_id: str, attribute_id: str):\n    \"\"\"Get a specific attribute node by its ID\"\"\"\n    attr_path = f\"graph_data/users/{user_id}/attributeNodes/{attribute_id}.json\"\n    if not os.path.exists(attr_path):\n        raise HTTPException(status_code=404, detail=\"AttributeNode not found\")\n    with open(attr_path, \"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.unlist_attribute_from_morph","title":"<code>unlist_attribute_from_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest)</code>","text":"<p>Remove an attribute from a specific morph without deleting the attribute itself. The attribute continues to exist in other morphs.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/attribute/unlist_from_morph/{node_id}/{attr_name}\")\ndef unlist_attribute_from_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest):\n    \"\"\"\n    Remove an attribute from a specific morph without deleting the attribute itself.\n    The attribute continues to exist in other morphs.\n    \"\"\"\n    try:\n        with graph_transaction(user_id, graph_id, \"unlist_attribute_from_morph\") as backup_dir:\n            morph_id = request.morph_id\n            # Find the attributeNode id by node_id and attr_name\n            reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n            registry = load_registry(reg_path)\n            attr_id = None\n            for k, v in registry.items():\n                if v.get(\"source_id\") == node_id and v.get(\"name\") == attr_name:\n                    attr_id = k\n                    break\n            if not attr_id:\n                raise HTTPException(status_code=404, detail=\"AttributeNode not found\")\n\n            # Update source node to remove attribute from specific morph\n            source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n            if not source_node_path.exists():\n                raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n            source_node = load_json_file(source_node_path)\n\n            # Find the specific morph and remove the attribute\n            morph_found = False\n            for morph in source_node.get(\"morphs\", []):\n                if morph.get(\"morph_id\") == morph_id:\n                    morph_found = True\n                    if \"attributeNode_ids\" in morph and attr_id in morph[\"attributeNode_ids\"]:\n                        morph[\"attributeNode_ids\"].remove(attr_id)\n                        break\n\n            if not morph_found:\n                raise HTTPException(status_code=404, detail=f\"Morph {morph_id} not found\")\n\n            # Atomically save updated source node\n            atomic_node_save(user_id, node_id, source_node)\n\n            # Regenerate composed files atomically\n            try:\n                node_ids = get_graph_node_ids(user_id, graph_id)\n                metadata_path = Path(f\"graph_data/users/{user_id}/graphs/{graph_id}/metadata.yaml\")\n                graph_description = \"\"\n                if metadata_path.exists():\n                    import yaml\n                    with open(metadata_path, \"r\") as f:\n                        metadata = yaml.safe_load(f) or {}\n                        graph_description = metadata.get(\"description\", \"\")\n\n                composed_data = compose_graph(user_id, graph_id, node_ids, graph_description)\n                if composed_data:\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"json\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"yaml\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"polymorphic\"], \"polymorphic\")\n            except Exception as e:\n                print(f\"Warning: Failed to regenerate composed files: {e}\")\n\n            return {\"status\": \"Attribute unlisted from morph\", \"attribute_id\": attr_id, \"morph_id\": morph_id}\n\n    except AtomicityError as e:\n        raise HTTPException(status_code=500, detail=f\"Atomic operation failed: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to unlist attribute from morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.add_attribute_to_morph","title":"<code>add_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest)</code>","text":"<p>Add an existing attribute to a specific morph.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/attribute/add_to_morph/{node_id}/{attr_name}\")\ndef add_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest):\n    \"\"\"\n    Add an existing attribute to a specific morph.\n    \"\"\"\n    try:\n        with graph_transaction(user_id, graph_id, \"add_attribute_to_morph\") as backup_dir:\n            morph_id = request.morph_id\n            # Find the attributeNode id by node_id and attr_name\n            reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n            registry = load_registry(reg_path)\n            attr_id = None\n            for k, v in registry.items():\n                if v.get(\"source_id\") == node_id and v.get(\"name\") == attr_name:\n                    attr_id = k\n                    break\n            if not attr_id:\n                raise HTTPException(status_code=404, detail=\"AttributeNode not found\")\n\n            # Update source node to add attribute to specific morph\n            source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n            if not source_node_path.exists():\n                raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n            source_node = load_json_file(source_node_path)\n\n            # Find the specific morph and add the attribute\n            morph_found = False\n            for morph in source_node.get(\"morphs\", []):\n                if morph.get(\"morph_id\") == morph_id:\n                    morph_found = True\n                    if \"attributeNode_ids\" not in morph:\n                        morph[\"attributeNode_ids\"] = []\n                    if attr_id not in morph[\"attributeNode_ids\"]:\n                        morph[\"attributeNode_ids\"].append(attr_id)\n                    break\n\n            if not morph_found:\n                raise HTTPException(status_code=404, detail=f\"Morph {morph_id} not found\")\n\n            # Atomically save updated source node\n            atomic_node_save(user_id, node_id, source_node)\n\n            # Regenerate composed files atomically\n            try:\n                node_ids = get_graph_node_ids(user_id, graph_id)\n                metadata_path = Path(f\"graph_data/users/{user_id}/graphs/{graph_id}/metadata.yaml\")\n                graph_description = \"\"\n                if metadata_path.exists():\n                    import yaml\n                    with open(metadata_path, \"r\") as f:\n                        metadata = yaml.safe_load(f) or {}\n                        graph_description = metadata.get(\"description\", \"\")\n\n                composed_data = compose_graph(user_id, graph_id, node_ids, graph_description)\n                if composed_data:\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"json\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"yaml\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"polymorphic\"], \"polymorphic\")\n            except Exception as e:\n                print(f\"Warning: Failed to regenerate composed files: {e}\")\n\n            return {\"status\": \"Attribute added to morph\", \"attribute_id\": attr_id, \"morph_id\": morph_id}\n\n    except AtomicityError as e:\n        raise HTTPException(status_code=500, detail=f\"Atomic operation failed: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to add attribute to morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.move_attribute_to_morph","title":"<code>move_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MoveMorphRequest)</code>","text":"<p>Move an attribute from one morph to another.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/attribute/move_to_morph/{node_id}/{attr_name}\")\ndef move_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MoveMorphRequest):\n    \"\"\"\n    Move an attribute from one morph to another.\n    \"\"\"\n    try:\n        print(f\"[DEBUG] move_attribute_to_morph called: user_id={user_id}, graph_id={graph_id}, node_id={node_id}, attr_name={attr_name}, from_morph_id={request.from_morph_id}, to_morph_id={request.to_morph_id}\")\n        with graph_transaction(user_id, graph_id, \"move_attribute_to_morph\") as backup_dir:\n            from_morph_id = request.from_morph_id\n            to_morph_id = request.to_morph_id\n            # Find the attributeNode id by node_id and attr_name\n            reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n            registry = load_registry(reg_path)\n            attr_id = None\n            for k, v in registry.items():\n                if v.get(\"source_id\") == node_id and v.get(\"name\") == attr_name:\n                    attr_id = k\n                    break\n            print(f\"[DEBUG] Found attr_id: {attr_id}\")\n            if not attr_id:\n                raise HTTPException(status_code=404, detail=\"AttributeNode not found\")\n\n            # Update source node to move attribute between morphs\n            source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n            if not source_node_path.exists():\n                raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n            source_node = load_json_file(source_node_path)\n\n            # Find both morphs\n            from_morph = None\n            to_morph = None\n            for morph in source_node.get(\"morphs\", []):\n                if morph.get(\"morph_id\") == from_morph_id:\n                    from_morph = morph\n                if morph.get(\"morph_id\") == to_morph_id:\n                    to_morph = morph\n            print(f\"[DEBUG] from_morph: {from_morph}\")\n            print(f\"[DEBUG] to_morph: {to_morph}\")\n            if not from_morph:\n                raise HTTPException(status_code=404, detail=f\"Source morph {from_morph_id} not found\")\n            if not to_morph:\n                raise HTTPException(status_code=404, detail=f\"Target morph {to_morph_id} not found\")\n            print(f\"[DEBUG] from_morph attributeNode_ids before: {from_morph.get('attributeNode_ids', [])}\")\n            print(f\"[DEBUG] to_morph attributeNode_ids before: {to_morph.get('attributeNode_ids', [])}\")\n            # Remove from source morph\n            if \"attributeNode_ids\" in from_morph and attr_id in from_morph[\"attributeNode_ids\"]:\n                from_morph[\"attributeNode_ids\"].remove(attr_id)\n            # Add to target morph\n            if \"attributeNode_ids\" not in to_morph:\n                to_morph[\"attributeNode_ids\"] = []\n            if attr_id not in to_morph[\"attributeNode_ids\"]:\n                to_morph[\"attributeNode_ids\"].append(attr_id)\n            print(f\"[DEBUG] from_morph attributeNode_ids after: {from_morph.get('attributeNode_ids', [])}\")\n            print(f\"[DEBUG] to_morph attributeNode_ids after: {to_morph.get('attributeNode_ids', [])}\")\n            # Atomically save updated source node\n            atomic_node_save(user_id, node_id, source_node)\n            # Regenerate composed files atomically\n            try:\n                node_ids = get_graph_node_ids(user_id, graph_id)\n                metadata_path = Path(f\"graph_data/users/{user_id}/graphs/{graph_id}/metadata.yaml\")\n                graph_description = \"\"\n                if metadata_path.exists():\n                    import yaml\n                    with open(metadata_path, \"r\") as f:\n                        metadata = yaml.safe_load(f) or {}\n                        graph_description = metadata.get(\"description\", \"\")\n                composed_data = compose_graph(user_id, graph_id, node_ids, graph_description)\n                if composed_data:\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"json\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"yaml\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"polymorphic\"], \"polymorphic\")\n            except Exception as e:\n                print(f\"Warning: Failed to regenerate composed files: {e}\")\n            return {\"status\": \"Attribute moved between morphs\", \"attribute_id\": attr_id, \"from_morph_id\": from_morph_id, \"to_morph_id\": to_morph_id}\n    except AtomicityError as e:\n        raise HTTPException(status_code=500, detail=f\"Atomic operation failed: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to move attribute between morphs: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.copy_attribute_to_morph","title":"<code>copy_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest)</code>","text":"<p>Copy an existing attribute to a specific morph (keeps it in all other morphs as well).</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/attribute/copy_to_morph/{node_id}/{attr_name}\")\ndef copy_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest):\n    \"\"\"\n    Copy an existing attribute to a specific morph (keeps it in all other morphs as well).\n    \"\"\"\n    try:\n        with graph_transaction(user_id, graph_id, \"copy_attribute_to_morph\") as backup_dir:\n            morph_id = request.morph_id\n            # Find the attributeNode id by node_id and attr_name\n            reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n            registry = load_registry(reg_path)\n            attr_id = None\n            for k, v in registry.items():\n                if v.get(\"source_id\") == node_id and v.get(\"name\") == attr_name:\n                    attr_id = k\n                    break\n\n            if not attr_id:\n                raise HTTPException(status_code=404, detail=\"Attribute not found\")\n\n            # Load the source node\n            source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n            if not source_node_path.exists():\n                raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n            source_node = load_json_file(source_node_path)\n\n            # Ensure morphs array exists\n            if \"morphs\" not in source_node:\n                source_node[\"morphs\"] = []\n\n            # Find the target morph\n            target_morph = None\n            for morph in source_node[\"morphs\"]:\n                if morph.get(\"morph_id\") == morph_id:\n                    target_morph = morph\n                    break\n\n            if not target_morph:\n                raise HTTPException(status_code=404, detail=\"Target morph not found\")\n\n            # Ensure attributeNode_ids array exists\n            if \"attributeNode_ids\" not in target_morph:\n                target_morph[\"attributeNode_ids\"] = []\n\n            # Add attribute to the morph if not already present\n            if attr_id not in target_morph[\"attributeNode_ids\"]:\n                target_morph[\"attributeNode_ids\"].append(attr_id)\n\n                # Atomically save the updated node\n                atomic_node_save(user_id, node_id, source_node)\n\n                # Regenerate composed files\n                try:\n                    node_ids = get_graph_node_ids(user_id, graph_id)\n                    metadata_path = Path(f\"graph_data/users/{user_id}/graphs/{graph_id}/metadata.yaml\")\n                    graph_description = \"\"\n                    if metadata_path.exists():\n                        import yaml\n                        with open(metadata_path, \"r\") as f:\n                            metadata = yaml.safe_load(f) or {}\n                            graph_description = metadata.get(\"description\", \"\")\n\n                    composed_data = compose_graph(user_id, graph_id, node_ids, graph_description)\n                    if composed_data:\n                        atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"json\")\n                        atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"yaml\")\n                        atomic_composed_save(user_id, graph_id, composed_data[\"polymorphic\"], \"polymorphic\")\n                except Exception as e:\n                    print(f\"Warning: Failed to regenerate composed files: {e}\")\n\n                return {\"status\": \"Attribute copied to morph\", \"attribute_id\": attr_id, \"morph_id\": morph_id}\n            else:\n                return {\"status\": \"Attribute already exists in target morph\", \"attribute_id\": attr_id, \"morph_id\": morph_id}\n\n    except AtomicityError as e:\n        raise HTTPException(status_code=500, detail=f\"Atomic operation failed: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to copy attribute to morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.list_attributes_by_morph","title":"<code>list_attributes_by_morph(user_id: str, graph_id: str, node_id: str)</code>","text":"<p>List all attributes organized by morph for a given node.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.get(\"/users/{user_id}/graphs/{graph_id}/attribute/list_by_morph/{node_id}\")\ndef list_attributes_by_morph(user_id: str, graph_id: str, node_id: str):\n    \"\"\"\n    List all attributes organized by morph for a given node.\n    \"\"\"\n    try:\n        # Load source node\n        source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n        if not source_node_path.exists():\n            raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n        source_node = load_json_file(source_node_path)\n\n        # Load attribute registry\n        reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n        registry = load_registry(reg_path)\n\n        # Organize attributes by morph\n        morph_attributes = {}\n        for morph in source_node.get(\"morphs\", []):\n            morph_id = morph.get(\"morph_id\")\n            morph_name = morph.get(\"name\", \"Unknown\")\n            morph_attributes[morph_id] = {\n                \"morph_id\": morph_id,\n                \"morph_name\": morph_name,\n                \"attributes\": []\n            }\n\n            for attr_id in morph.get(\"attributeNode_ids\", []):\n                if attr_id in registry:\n                    attr_info = registry[attr_id]\n\n                    # Load full attribute data from the attribute file\n                    attr_file_path = Path(f\"graph_data/users/{user_id}/attributeNodes/{attr_id}.json\")\n                    full_attr_data = {}\n                    if attr_file_path.exists():\n                        try:\n                            full_attr_data = load_json_file(attr_file_path)\n                        except Exception as e:\n                            print(f\"Warning: Failed to load attribute file {attr_id}: {e}\")\n\n                    # Combine registry info with full attribute data\n                    attribute_data = {\n                        \"attribute_id\": attr_id,\n                        \"name\": attr_info.get(\"name\"),\n                        \"source_id\": attr_info.get(\"source_id\"),\n                        \"value\": full_attr_data.get(\"value\"),\n                        \"unit\": full_attr_data.get(\"unit\"),\n                        \"adverb\": full_attr_data.get(\"adverb\"),\n                        \"modality\": full_attr_data.get(\"modality\")\n                    }\n\n                    morph_attributes[morph_id][\"attributes\"].append(attribute_data)\n\n        return {\"node_id\": node_id, \"morphs\": morph_attributes}\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to list attributes by morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.list_relations_by_morph","title":"<code>list_relations_by_morph(user_id: str, graph_id: str, node_id: str)</code>","text":"<p>List all relations organized by morph for a given node.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.get(\"/users/{user_id}/graphs/{graph_id}/relation/list_by_morph/{node_id}\")\ndef list_relations_by_morph(user_id: str, graph_id: str, node_id: str):\n    \"\"\"\n    List all relations organized by morph for a given node.\n    \"\"\"\n    try:\n        # Load source node\n        source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n        if not source_node_path.exists():\n            raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n        source_node = load_json_file(source_node_path)\n\n        # Load relation registry\n        reg_path = Path(f\"graph_data/users/{user_id}/relation_registry.json\")\n        registry = load_registry(reg_path)\n\n        # Organize relations by morph\n        morph_relations = {}\n        for morph in source_node.get(\"morphs\", []):\n            morph_id = morph.get(\"morph_id\")\n            morph_name = morph.get(\"name\", \"Unknown\")\n            morph_relations[morph_id] = {\n                \"morph_id\": morph_id,\n                \"morph_name\": morph_name,\n                \"relations\": []\n            }\n\n            for rel_id in morph.get(\"relationNode_ids\", []):\n                if rel_id in registry:\n                    rel_info = registry[rel_id]\n\n                    # Load full relation data from the relation file\n                    rel_file_path = Path(f\"graph_data/users/{user_id}/relationNodes/{rel_id}.json\")\n                    full_rel_data = {}\n                    if rel_file_path.exists():\n                        try:\n                            full_rel_data = load_json_file(rel_file_path)\n                        except Exception as e:\n                            print(f\"Warning: Failed to load relation file {rel_id}: {e}\")\n\n                    # Combine registry info with full relation data\n                    relation_data = {\n                        \"relation_id\": rel_id,\n                        \"name\": rel_info.get(\"name\"),\n                        \"source_id\": rel_info.get(\"source_id\"),\n                        \"target_id\": rel_info.get(\"target_id\"),\n                        \"adverb\": full_rel_data.get(\"adverb\"),\n                        \"modality\": full_rel_data.get(\"modality\")\n                    }\n\n                    morph_relations[morph_id][\"relations\"].append(relation_data)\n\n        return {\"node_id\": node_id, \"morphs\": morph_relations}\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to list relations by morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.create_morph","title":"<code>create_morph(user_id: str, graph_id: str, request: CreateMorphRequest)</code>","text":"<p>Create a new morph for a node.</p> <p>Scenarios: 1. Empty morph: copy_from_morph is None - creates morph with empty properties 2. Copy from existing morph: copy_from_morph specifies any existing morph to copy from 3. Node context is always required - morphs must belong to a node</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/morph/create\")\ndef create_morph(user_id: str, graph_id: str, request: CreateMorphRequest):\n    \"\"\"\n    Create a new morph for a node.\n\n    Scenarios:\n    1. Empty morph: copy_from_morph is None - creates morph with empty properties\n    2. Copy from existing morph: copy_from_morph specifies any existing morph to copy from\n    3. Node context is always required - morphs must belong to a node\n    \"\"\"\n    try:\n        print(f\"DEBUG: Morph creation called with:\")\n        print(f\"  user_id: {user_id}\")\n        print(f\"  graph_id: {graph_id}\")\n        print(f\"  node_id: {request.node_id}\")\n        print(f\"  name: {request.name}\")\n        print(f\"  copy_from_morph: {request.copy_from_morph}\")\n        print(f\"  auto-generated morph_id: {request.name}_{request.node_id}\")\n\n        with graph_transaction(user_id, graph_id, \"create_morph\") as backup_dir:\n            # Auto-generate morph_id from name and node_id\n            morph_id = f\"{request.name}_{request.node_id}\"\n            node_id = request.node_id\n            morph_name = request.name\n            copy_from_morph = request.copy_from_morph\n\n            # Load the source node (required context)\n            source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n            if not source_node_path.exists():\n                raise HTTPException(status_code=404, detail=f\"Node {node_id} not found\")\n\n            with open(source_node_path, 'r') as f:\n                source_node = json.load(f)\n\n            # Check if morph already exists\n            existing_morph = None\n            for morph in source_node.get(\"morphs\", []):\n                if morph.get(\"morph_id\") == morph_id:\n                    existing_morph = morph\n                    break\n\n            if existing_morph:\n                # Morph already exists, but we need to ensure registries are updated\n                print(f\"DEBUG: Morph {morph_id} already exists, checking registry updates\")\n\n                # If copying from another morph, ensure registries are updated\n                if copy_from_morph:\n                    print(f\"DEBUG: Updating registries for existing morph {morph_id}\")\n\n                    # Update registries to include the morph_id for all relations and attributes\n                    # Update relation registry\n                    rel_reg_path = Path(f\"graph_data/users/{user_id}/relation_registry.json\")\n                    if rel_reg_path.exists():\n                        rel_registry = load_json_file(rel_reg_path)\n                        for rel_id in existing_morph.get(\"relationNode_ids\", []):\n                            if rel_id in rel_registry:\n                                current_morph_ids = rel_registry[rel_id].get(\"morph_id\", [])\n                                if isinstance(current_morph_ids, str):\n                                    current_morph_ids = [current_morph_ids]\n                                if morph_id not in current_morph_ids:\n                                    current_morph_ids.append(morph_id)\n                                    rel_registry[rel_id][\"morph_id\"] = current_morph_ids\n                        atomic_registry_save(user_id, \"relation\", rel_registry)\n\n                    # Update attribute registry\n                    attr_reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n                    if attr_reg_path.exists():\n                        attr_registry = load_json_file(attr_reg_path)\n                        for attr_id in existing_morph.get(\"attributeNode_ids\", []):\n                            if attr_id in attr_registry:\n                                current_morph_ids = attr_registry[attr_id].get(\"morph_id\", [])\n                                if isinstance(current_morph_ids, str):\n                                    current_morph_ids = [current_morph_ids]\n                                if morph_id not in current_morph_ids:\n                                    current_morph_ids.append(morph_id)\n                                    attr_registry[attr_id][\"morph_id\"] = current_morph_ids\n                        atomic_registry_save(user_id, \"attribute\", attr_registry)\n\n                # Return success if morph already exists (idempotent behavior)\n                return {\n                    \"status\": \"Morph already exists\",\n                    \"morph_id\": morph_id,\n                    \"node_id\": node_id,\n                    \"name\": morph_name,\n                    \"copied_from\": copy_from_morph,\n                    \"relation_count\": len(existing_morph.get(\"relationNode_ids\", [])),\n                    \"attribute_count\": len(existing_morph.get(\"attributeNode_ids\", []))\n                }\n\n            # Create new morph\n            new_morph = {\n                \"morph_id\": morph_id,\n                \"node_id\": node_id,\n                \"name\": morph_name,\n                \"relationNode_ids\": [],\n                \"attributeNode_ids\": []\n            }\n\n            # If copying from another morph, copy all properties\n            print(f\"DEBUG: About to check copy_from_morph condition: {copy_from_morph}\")\n            print(f\"DEBUG: copy_from_morph type: {type(copy_from_morph)}\")\n            print(f\"DEBUG: copy_from_morph truthiness: {bool(copy_from_morph)}\")\n            if copy_from_morph:\n                print(f\"DEBUG: Copying from morph: {copy_from_morph}\")\n                # Reload the node file to ensure latest state\n                with open(source_node_path, 'r') as f:\n                    source_node = json.load(f)\n                print(f\"DEBUG: Loaded source node with {len(source_node.get('morphs', []))} morphs\")\n                source_morph = None\n                for morph in source_node.get(\"morphs\", []):\n                    print(f\"DEBUG: Checking morph: {morph.get('morph_id')}\")\n                    if morph.get(\"morph_id\") == copy_from_morph:\n                        source_morph = morph\n                        print(f\"DEBUG: Found source morph: {copy_from_morph}\")\n                        break\n\n                if not source_morph:\n                    print(f\"DEBUG: Source morph {copy_from_morph} not found!\")\n                    raise HTTPException(status_code=404, detail=f\"Source morph {copy_from_morph} not found in node {node_id}\")\n\n                print(f\"DEBUG: Copying from source morph {copy_from_morph}\")\n                print(f\"DEBUG: Source morph relationNode_ids: {source_morph.get('relationNode_ids', [])}\")\n                print(f\"DEBUG: Source morph attributeNode_ids: {source_morph.get('attributeNode_ids', [])}\")\n\n                # Copy relations and attributes\n                new_morph[\"relationNode_ids\"] = source_morph.get(\"relationNode_ids\", []).copy()\n                new_morph[\"attributeNode_ids\"] = source_morph.get(\"attributeNode_ids\", []).copy()\n\n                print(f\"DEBUG: New morph relationNode_ids: {new_morph['relationNode_ids']}\")\n                print(f\"DEBUG: New morph attributeNode_ids: {new_morph['attributeNode_ids']}\")\n\n                # Update registries to include the new morph_id for all copied relations and attributes\n                # Update relation registry\n                rel_reg_path = Path(f\"graph_data/users/{user_id}/relation_registry.json\")\n                print(f\"DEBUG: Checking relation registry at {rel_reg_path}\")\n                print(f\"DEBUG: Relation registry exists: {rel_reg_path.exists()}\")\n                if rel_reg_path.exists():\n                    rel_registry = load_json_file(rel_reg_path)\n                    print(f\"DEBUG: Current relation registry keys: {list(rel_registry.keys())}\")\n                    for rel_id in new_morph[\"relationNode_ids\"]:\n                        print(f\"DEBUG: Processing relation {rel_id}\")\n                        if rel_id in rel_registry:\n                            current_morph_ids = rel_registry[rel_id].get(\"morph_id\", [])\n                            print(f\"DEBUG: Current morph_ids for {rel_id}: {current_morph_ids}\")\n                            if isinstance(current_morph_ids, str):\n                                current_morph_ids = [current_morph_ids]\n                            if morph_id not in current_morph_ids:\n                                current_morph_ids.append(morph_id)\n                            print(f\"DEBUG: Updated morph_ids for {rel_id}: {current_morph_ids}\")\n                            rel_registry[rel_id][\"morph_id\"] = current_morph_ids\n                        else:\n                            print(f\"DEBUG: Relation {rel_id} not found in registry\")\n                    print(f\"DEBUG: Saving updated relation registry\")\n                    atomic_registry_save(user_id, \"relation\", rel_registry)\n\n                # Update attribute registry\n                attr_reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n                print(f\"DEBUG: Checking attribute registry at {attr_reg_path}\")\n                print(f\"DEBUG: Attribute registry exists: {attr_reg_path.exists()}\")\n                if attr_reg_path.exists():\n                    attr_registry = load_json_file(attr_reg_path)\n                    print(f\"DEBUG: Current attribute registry keys: {list(attr_registry.keys())}\")\n                    for attr_id in new_morph[\"attributeNode_ids\"]:\n                        print(f\"DEBUG: Processing attribute {attr_id}\")\n                        if attr_id in attr_registry:\n                            current_morph_ids = attr_registry[attr_id].get(\"morph_id\", [])\n                            print(f\"DEBUG: Current morph_ids for {attr_id}: {current_morph_ids}\")\n                            if isinstance(current_morph_ids, str):\n                                current_morph_ids = [current_morph_ids]\n                            if morph_id not in current_morph_ids:\n                                current_morph_ids.append(morph_id)\n                            print(f\"DEBUG: Updated morph_ids for {attr_id}: {current_morph_ids}\")\n                            attr_registry[attr_id][\"morph_id\"] = current_morph_ids\n                        else:\n                            print(f\"DEBUG: Attribute {attr_id} not found in registry\")\n                    print(f\"DEBUG: Saving updated attribute registry\")\n                    atomic_registry_save(user_id, \"attribute\", attr_registry)\n                else:\n                    print(f\"DEBUG: Attribute registry does not exist\")\n\n            # Add new morph to node\n            if \"morphs\" not in source_node:\n                source_node[\"morphs\"] = []\n            source_node[\"morphs\"].append(new_morph)\n\n            # Save updated node\n            with open(source_node_path, 'w') as f:\n                json.dump(source_node, f, indent=2)\n\n            return {\n                \"status\": \"Morph created successfully\",\n                \"morph_id\": morph_id,\n                \"node_id\": node_id,\n                \"name\": morph_name,\n                \"copied_from\": copy_from_morph,\n                \"relation_count\": len(new_morph[\"relationNode_ids\"]),\n                \"attribute_count\": len(new_morph[\"attributeNode_ids\"]),\n                \"is_empty\": copy_from_morph is None\n            }\n\n    except AtomicityError as e:\n        raise HTTPException(status_code=500, detail=f\"Atomic operation failed: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to create morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.get_graph_node_ids","title":"<code>get_graph_node_ids(user_id: str, graph_id: str) -&gt; list[str]</code>","text":"<p>Get list of node IDs that belong to a specific graph</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>def get_graph_node_ids(user_id: str, graph_id: str) -&gt; list[str]:\n    \"\"\"Get list of node IDs that belong to a specific graph\"\"\"\n    from backend.core.registry import load_node_registry\n    registry = load_node_registry(user_id)\n    graph_nodes = []\n\n    for node_id, entry in registry.items():\n        if \"graphs\" in entry and graph_id in entry[\"graphs\"]:\n            graph_nodes.append(node_id)\n\n    return graph_nodes\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.get_relation_node","title":"<code>get_relation_node(user_id: str, graph_id: str, relation_id: str)</code>","text":"<p>Get a specific relation node by its ID</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.get(\"/users/{user_id}/graphs/{graph_id}/relationNodes/{relation_id}\")\ndef get_relation_node(user_id: str, graph_id: str, relation_id: str):\n    \"\"\"Get a specific relation node by its ID\"\"\"\n    rel_path = f\"graph_data/users/{user_id}/relationNodes/{relation_id}.json\"\n    if not os.path.exists(rel_path):\n        raise HTTPException(status_code=404, detail=\"RelationNode not found\")\n    with open(rel_path, \"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.validate_graph_consistency","title":"<code>validate_graph_consistency(user_id: str, graph_id: str)</code>","text":"<p>Validate the consistency of a graph's data.</p> <p>This endpoint performs comprehensive validation of: - Node registry consistency - Relation registry consistency - Attribute registry consistency - File existence checks - Reference integrity</p> <p>Returns validation results with issues and warnings.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.get(\"/users/{user_id}/graphs/{graph_id}/validate\")\ndef validate_graph_consistency(user_id: str, graph_id: str):\n    \"\"\"\n    Validate the consistency of a graph's data.\n\n    This endpoint performs comprehensive validation of:\n    - Node registry consistency\n    - Relation registry consistency  \n    - Attribute registry consistency\n    - File existence checks\n    - Reference integrity\n\n    Returns validation results with issues and warnings.\n    \"\"\"\n    try:\n        validation_result = validate_consistency(user_id)\n        return validation_result\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Validation failed: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.cleanup_old_backups","title":"<code>cleanup_old_backups(user_id: str, graph_id: str, max_age_hours: int = 24)</code>","text":"<p>Clean up old backup directories for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID</p> required <code>graph_id</code> <code>str</code> <p>Graph ID (not used but kept for consistency)</p> required <code>max_age_hours</code> <code>int</code> <p>Maximum age of backups to keep (default: 24 hours)</p> <code>24</code> <p>Returns:</p> Type Description <p>Number of backups cleaned up</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/cleanup-backups\")\ndef cleanup_old_backups(user_id: str, graph_id: str, max_age_hours: int = 24):\n    \"\"\"\n    Clean up old backup directories for a user.\n\n    Args:\n        user_id: User ID\n        graph_id: Graph ID (not used but kept for consistency)\n        max_age_hours: Maximum age of backups to keep (default: 24 hours)\n\n    Returns:\n        Number of backups cleaned up\n    \"\"\"\n    try:\n        cleaned_count = cleanup_backups(user_id, max_age_hours)\n        return {\n            \"status\": \"Backup cleanup completed\",\n            \"cleaned_count\": cleaned_count,\n            \"max_age_hours\": max_age_hours\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Backup cleanup failed: {str(e)}\")\n</code></pre>"},{"location":"development/installation/","title":"Installation Guide","text":"<p>This guide will help you set up the NDF Studio backend for development.</p>"},{"location":"development/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+: The backend requires Python 3.8 or higher</li> <li>Git: For cloning the repository</li> <li>Virtual Environment: Recommended for Python dependency management</li> </ul>"},{"location":"development/installation/#step-by-step-installation","title":"Step-by-Step Installation","text":""},{"location":"development/installation/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/gnowledge/nodeBook.git\ncd nodeBook\n</code></pre>"},{"location":"development/installation/#2-set-up-python-virtual-environment","title":"2. Set Up Python Virtual Environment","text":"<pre><code># Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# On Linux/macOS:\nsource venv/bin/activate\n# On Windows:\nvenv\\Scripts\\activate\n</code></pre>"},{"location":"development/installation/#3-install-dependencies","title":"3. Install Dependencies","text":"<pre><code># Install Python dependencies\npip install -r backend/requirements.txt\n\n# Install spaCy model (required for CNL parsing)\npython -m spacy download en_core_web_sm\n</code></pre>"},{"location":"development/installation/#4-set-up-environment-variables","title":"4. Set Up Environment Variables","text":"<p>Create a <code>.env</code> file in the project root:</p> <pre><code># Backend configuration\nBACKEND_HOST=localhost\nBACKEND_PORT=8000\nDEBUG=True\n\n# Database configuration\nDATABASE_URL=sqlite:///./ndf_studio.db\n\n# JWT configuration\nJWT_SECRET_KEY=your-secret-key-here\nJWT_ALGORITHM=HS256\nJWT_ACCESS_TOKEN_EXPIRE_MINUTES=30\n\n# spaCy model\nSPACY_MODEL=en_core_web_sm\n</code></pre>"},{"location":"development/installation/#5-initialize-the-database","title":"5. Initialize the Database","text":"<pre><code># Run database migrations (if using Alembic)\n# alembic upgrade head\n\n# Or create initial database\npython -c \"from backend.core.models import *; from backend.config import get_data_root; print('Database initialized')\"\n</code></pre>"},{"location":"development/installation/#6-create-admin-user","title":"6. Create Admin User","text":"<pre><code># Run the post-install script to create admin user\npython scripts/post_install.py\n</code></pre>"},{"location":"development/installation/#running-the-application","title":"Running the Application","text":""},{"location":"development/installation/#development-server","title":"Development Server","text":"<pre><code># Start the backend server\nbash scripts/start_backend.sh\n\n# Or manually\ncd backend\nuvicorn main:app --reload --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"development/installation/#production-server","title":"Production Server","text":"<pre><code># For production deployment\ncd backend\nuvicorn main:app --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"development/installation/#verification","title":"Verification","text":"<p>Once the server is running, you can verify the installation:</p> <ol> <li>Health Check: Visit <code>http://localhost:8000/api/health</code></li> <li>API Documentation: Visit <code>http://localhost:8000/docs</code></li> <li>Alternative Docs: Visit <code>http://localhost:8000/redoc</code></li> </ol>"},{"location":"development/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/installation/#common-issues","title":"Common Issues","text":""},{"location":"development/installation/#import-errors","title":"Import Errors","text":"<p>If you encounter import errors, ensure you're in the correct directory and the virtual environment is activated:</p> <pre><code># Make sure you're in the project root\npwd  # Should show /path/to/nodeBook\n\n# Activate virtual environment\nsource venv/bin/activate\n\n# Check Python path\npython -c \"import sys; print('\\n'.join(sys.path))\"\n</code></pre>"},{"location":"development/installation/#spacy-model-issues","title":"spaCy Model Issues","text":"<p>If spaCy model is not found:</p> <pre><code># Reinstall spaCy model\npython -m spacy download en_core_web_sm\n\n# Verify installation\npython -c \"import spacy; nlp = spacy.load('en_core_web_sm'); print('spaCy model loaded successfully')\"\n</code></pre>"},{"location":"development/installation/#port-already-in-use","title":"Port Already in Use","text":"<p>If port 8000 is already in use:</p> <pre><code># Find process using port 8000\nlsof -i :8000\n\n# Kill the process\nkill -9 &lt;PID&gt;\n\n# Or use a different port\nuvicorn main:app --reload --host 0.0.0.0 --port 8001\n</code></pre>"},{"location":"development/installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Check the API Reference for available endpoints</li> <li>Run tests with <code>bash run_tests.sh</code></li> <li>Explore the codebase in the <code>backend/</code> directory </li> </ol>"}]}